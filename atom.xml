<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wayne&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wayneblog.cn/"/>
  <updated>2016-12-02T13:47:32.923Z</updated>
  <id>http://wayneblog.cn/</id>
  
  <author>
    <name>Wayne Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>server mock</title>
    <link href="http://wayneblog.cn/2016/12/02/server-mock/"/>
    <id>http://wayneblog.cn/2016/12/02/server-mock/</id>
    <published>2016-12-02T08:35:09.000Z</published>
    <updated>2016-12-02T13:47:32.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、nodejs服务器"><a href="#一、nodejs服务器" class="headerlink" title="一、nodejs服务器"></a>一、nodejs服务器</h2><ol>
<li>为什么要有mock？<br>因为前端在发请求给后端的时候是依赖于后端的响应的，没有得到响应无法进行下一步，所以我们要想方设法自己模拟返回的数据，这个过程就叫做mock；</li>
<li>我们的本地IP是127.0.0.1</li>
<li>server服务器必须监听本地端口，server.listen(‘8888’)</li>
<li><p>要想创建http服务器，须先引用server模块，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>正常的网页返回的是文件而不是字符串，所以我们为了返回文件引入了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;) //nodejs内置的文件系统file system</div></pre></td></tr></table></figure>
</li>
<li><p>用http的createServer创建一个http服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var server = http.createServer(function(request,response)&#123;</div><div class="line">    response.writeHead(200);//返回的状态码</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>fs的readFile方法可以读文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;index.html&apos;,function(error,content)&#123;</div><div class="line">        //因为是回调函数所以必须在readFile后才会触发</div><div class="line">        //正因如此我们必须把返回的结果也放进来，要是放在函数外面的话，可能还没读完文件就赋值了会undefined</div><div class="line">        var fileContent = content.toString();//默认的content是二进制的格式</div><div class="line">        response.end(fileContent);//这是响应的内容</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>nodejs的核心就是理解请求和响应</p>
</li>
<li>默认响应给浏览器的有response.end()还有favicon，我们需要将favicon变成404，即用url来区分</li>
<li>request.method可以知道是用GET请求还是POST请求</li>
<li>整个过程就是，浏览器发送请求给服务器，服务器必须监听了跟浏览器同样的端口才能接收请求并作出响应；服务器会跟句request的需求返回对应的响应，一个请求对应一个响应，不能对应多个响应；</li>
<li>request包括url， response包括状态码+字符串</li>
</ol>
<p><img src="/images/server-mock/server_mock1.jpeg" alt=""><br><img src="/images/server-mock/server_mock2.jpeg" alt=""><br><img src="/images/server-mock/server_mock3.jpeg" alt=""><br><img src="/images/server-mock/server_mock4.jpeg" alt=""><br><img src="/images/server-mock/server_mock5.jpeg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      自己总结的mock数据的方法
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="ajax" scheme="http://wayneblog.cn/tags/ajax/"/>
    
      <category term="server" scheme="http://wayneblog.cn/tags/server/"/>
    
      <category term="mock" scheme="http://wayneblog.cn/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>Ajax&amp;Jsonp</title>
    <link href="http://wayneblog.cn/2016/10/12/ajax&amp;jsonp/"/>
    <id>http://wayneblog.cn/2016/10/12/ajax&amp;jsonp/</id>
    <published>2016-10-12T02:25:20.000Z</published>
    <updated>2016-12-13T05:44:19.912Z</updated>
    
    <summary type="html">
    
      关于ajax在JS和JQ中的总结
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="ajax" scheme="http://wayneblog.cn/tags/ajax/"/>
    
      <category term="jsonp" scheme="http://wayneblog.cn/tags/jsonp/"/>
    
      <category term="cors" scheme="http://wayneblog.cn/tags/cors/"/>
    
      <category term="跨域" scheme="http://wayneblog.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="同域" scheme="http://wayneblog.cn/tags/%E5%90%8C%E5%9F%9F/"/>
    
      <category term="server-mock" scheme="http://wayneblog.cn/tags/server-mock/"/>
    
  </entry>
  
  <entry>
    <title>错误处理机制</title>
    <link href="http://wayneblog.cn/2016/10/08/Error/"/>
    <id>http://wayneblog.cn/2016/10/08/Error/</id>
    <published>2016-10-08T02:25:20.000Z</published>
    <updated>2016-12-13T04:51:26.506Z</updated>
    
    <summary type="html">
    
      补充知识
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="http://wayneblog.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript重要知识及知识补充</title>
    <link href="http://wayneblog.cn/2016/10/05/javascript/"/>
    <id>http://wayneblog.cn/2016/10/05/javascript/</id>
    <published>2016-10-05T03:35:09.000Z</published>
    <updated>2016-12-13T05:30:58.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-数据类型、运算符、语句、变量"><a href="#一、-数据类型、运算符、语句、变量" class="headerlink" title="一、 数据类型、运算符、语句、变量"></a>一、 数据类型、运算符、语句、变量</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><ul>
<li>类型：<ul>
<li>基本类型</li>
<li>复杂类型</li>
</ul>
</li>
<li><p>类型检测：</p>
<ul>
<li><strong>typeof xxx</strong> 适用于基本类型和function；返回boolean、number、string、undefined、object、function;typeof null=&gt;object</li>
<li><strong>obj instanceof Function</strong> 适用于对象object，返回布尔值，左边是实例对象，右边是构造函数。它的运算实质是检查右边构建函数的原型对象，是否在左边对象的原型链上。；</li>
<li><p><strong>Object.prototype.toString.call()</strong> 适用于所有，比typeof更精准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//type函数可以替代typeof</div><div class="line">function type(o)&#123;</div><div class="line">	var str = Object.prototype.toString.call(o);</div><div class="line">	var type = str.match(/\[object (.*?)\]/)[1].toLowerCase();</div><div class="line">	return type;</div><div class="line">&#125;</div><div class="line">//判断数据类型返回布尔值</div><div class="line">[&apos;Null&apos;,&apos;Undefined&apos;,&apos;Function&apos;,&apos;Object&apos;,&apos;RegExp&apos;,&apos;Array&apos;,&apos;String&apos;,&apos;Number&apos;,&apos;Boolean&apos;,&apos;NaN&apos;,&apos;Inifinite&apos;].forEach(function(t)&#123;</div><div class="line">	type[&apos;is&apos;+t] = function(o)&#123;</div><div class="line">		return type(o) === t.toLowerCase();</div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>constructor</strong> </p>
</li>
<li><strong>duck type</strong> 根据类型特(属性或者方法)判断</li>
</ul>
</li>
</ul>
<h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><ul>
<li>‘==’ 用相等运算符会先将数据类型做转换再比较<ul>
<li>true ==&gt; 1</li>
<li>false ==&gt; 0</li>
<li>‘11’ ==&gt; 11</li>
<li>object ==&gt; number||string</li>
</ul>
</li>
<li><p>in运算符，主要用于对象，假如运用在数组的话需将数组转换成对象再使用；返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。受原型链影响；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function inArray(arr)&#123;</div><div class="line">	var obj = &#123;&#125;,</div><div class="line">			i;</div><div class="line">	for(i=0;i&lt;arr.length;i++)&#123;</div><div class="line">		obj[arr[i]] = &apos;&apos;;</div><div class="line">	&#125;</div><div class="line">	return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>delete,可以delete在全局和函数中没有用var声明的变量；可以delete对象的属性(完全delete而不是变为undefined)；可以delete数组中的数,变为undefined；</p>
</li>
</ul>
<h3 id="3-语句"><a href="#3-语句" class="headerlink" title="3.语句"></a>3.语句</h3><ul>
<li>for..in..语句<ul>
<li>顺序不确定</li>
<li>受原型链影响</li>
<li>只迭代enumerable:true的</li>
</ul>
</li>
<li>try..catch</li>
<li>for循环中的continue和break<ul>
<li>continue:相当于跳过，一般接在if判断语句后面，判断为true则跳过满足条件的循环而进行后面的循环;</li>
<li>break:直接跳出循环或代码块;</li>
</ul>
</li>
</ul>
<h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h3><ul>
<li>基本类型：在内存中占有一定的实际空间，当赋值后会在内存中创建一个新的副本，保存在栈内存中；</li>
<li>引用类型：在内存中保存的是一个指针，指向堆内存中的对象，赋值的时候也是创建一个新的指针指向对象，多个指针可同时指向一个对象；</li>
</ul>
<h2 id="二、属性标签、对象标签"><a href="#二、属性标签、对象标签" class="headerlink" title="二、属性标签、对象标签"></a>二、属性标签、对象标签</h2><h3 id="1-六种属性标签"><a href="#1-六种属性标签" class="headerlink" title="1.六种属性标签"></a>1.六种属性标签</h3><ul>
<li>value: 存放属性的属性值</li>
<li>writable: 表示value是否可改变，默认true</li>
<li>enumerable: 表示属性是否可枚举，默认true;如果为false，则for..in..和object.keys()会跳过</li>
<li>configurable: 表示可配置性，默认true;如果false,将无法删除该属性，也不能改变属性标签，控制了属性标签的可写性</li>
<li>get: 存放一个函数，表示该属性的取值函数（getter），默认为undefined。</li>
<li>set: set存放一个函数，表示该属性的存值函数（setter），默认为undefined。</li>
</ul>
<h3 id="2-属性标签关联方法"><a href="#2-属性标签关联方法" class="headerlink" title="2.属性标签关联方法"></a>2.属性标签关联方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//用来读取对象属性的标签</div><div class="line">Object.getOwnPropertyDescriptor(obj,&apos;property&apos;)&#123;&#125;</div><div class="line"></div><div class="line">//可定义或修改一个属性，然后返回修改后的对象</div><div class="line">//用Object.defineProperty定义的属性，writable、enumerable、configurable的默认值是false；</div><div class="line">Object.defineProperty(object,&apos;property&apos;,&#123;</div><div class="line">	value:</div><div class="line">	writable:</div><div class="line">	enumerable:</div><div class="line">	configurable:</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//一次性定义或修改多个属性</div><div class="line">Object.defineProperties(obj,&#123;prop1:&#123;&#125;,prop2:&#123;&#125;,prop3:&#123;&#125;...&#125;)</div><div class="line"></div><div class="line">//可获取对象上所有的key除了enumerable:false</div><div class="line">Object.keys(obj);</div><div class="line"></div><div class="line">//获取对象自身的所有属性，不管是否可枚举</div><div class="line">Object.getOwnPropertyNames()</div><div class="line"></div><div class="line">//判断一个属性是否可枚举</div><div class="line">Object.prototype.propertyIsEnumerable()</div></pre></td></tr></table></figure>
<h3 id="3-元属性详解"><a href="#3-元属性详解" class="headerlink" title="3.元属性详解"></a>3.元属性详解</h3><ul>
<li><p><strong>enumerable</strong></p>
<ul>
<li>设置了enumerable:false的属性不被for..in..、Object.keys()、JSON.stringify以上三种方法识别；</li>
<li>考虑到JSON.stringify方法会排除enumerable为false的值，有时可以利用这一点，为对象添加注释信息。</li>
</ul>
</li>
<li><p><strong>configurable</strong></p>
<ul>
<li>当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。</li>
<li>需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。</li>
<li>至于value，只要writable和configurable有一个为true，就允许改动。</li>
<li>configurable为false时，直接对该属性赋值，不报错，但不会成功。</li>
<li>可配置性决定了一个变量是否可以被删除（delete）。为true时才可以被delete</li>
</ul>
</li>
<li><p><strong>writable</strong></p>
<ul>
<li>可写性（writable）决定了属性的值（value）是否可以被改变。</li>
</ul>
</li>
</ul>
<h3 id="4-getter-amp-setter（存取器）"><a href="#4-getter-amp-setter（存取器）" class="headerlink" title="4.getter&amp;setter（存取器）"></a>4.getter&amp;setter（存取器）</h3><ul>
<li>存值函数:setter;使用set命令</li>
<li>取值函数:getter;使用get命令</li>
<li>存取器提供的是虚拟属性，即该属性的值不是实际存在的，而是每次读取时计算生成的。</li>
<li>存取器往往用于，属性的值需要依赖对象内部数据的场合。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//可直接在对象中定义</div><div class="line">var o =&#123;</div><div class="line">  $n : 5,</div><div class="line">  get next() &#123; return this.$n++ &#125;,</div><div class="line">  set next(n) &#123;</div><div class="line">    if (n &gt;= this.$n) this.$n = n;</div><div class="line">    else throw &apos;新的值必须大于当前值&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">o.next // 5</div><div class="line">o.next // 6</div><div class="line"></div><div class="line">o.next = 10;</div><div class="line">o.next // 10</div><div class="line"></div><div class="line">//可在Object.defineProperty中定义</div><div class="line">var d = new Date();</div><div class="line"></div><div class="line">Object.defineProperty(d, &apos;month&apos;, &#123;</div><div class="line">  get: function () &#123;</div><div class="line">    return d.getMonth();</div><div class="line">  &#125;,</div><div class="line">  set: function (v) &#123;</div><div class="line">    d.setMonth(v);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//存取器也可以使用Object.create方法定义</div><div class="line">var o = Object.create(Object.prototype, &#123;</div><div class="line">  foo: &#123;</div><div class="line">    get: function () &#123;</div><div class="line">      return &apos;getter&apos;;</div><div class="line">    &#125;,</div><div class="line">    set: function (value) &#123;</div><div class="line">      console.log(&apos;setter: &apos;+value);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      javascript的一些主心骨知识还有自己学习过程中漏掉的知识
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="http://wayneblog.cn/tags/javascript/"/>
    
      <category term="属性标签" scheme="http://wayneblog.cn/tags/%E5%B1%9E%E6%80%A7%E6%A0%87%E7%AD%BE/"/>
    
      <category term="闭包" scheme="http://wayneblog.cn/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="递归" scheme="http://wayneblog.cn/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="OOP" scheme="http://wayneblog.cn/tags/OOP/"/>
    
      <category term="标准库" scheme="http://wayneblog.cn/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="http://wayneblog.cn/2016/10/02/this/"/>
    <id>http://wayneblog.cn/2016/10/02/this/</id>
    <published>2016-10-02T04:35:20.000Z</published>
    <updated>2016-12-13T08:28:15.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h2><p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">    this.x = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。<br>下面分四种情况，详细讨论this的用法。</p>
<h3 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：<strong>纯粹的函数调用</strong></h3><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。<br>请看下面这段代码，它的运行结果是1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 1;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　test(); // 1</div></pre></td></tr></table></figure></p>
<p>为了证明this就是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　var x = 1;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　test(); // 1</div></pre></td></tr></table></figure></p>
<p>运行结果还是1。再变一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　var x = 1;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 0;</div><div class="line">　　&#125;</div><div class="line">　　test();</div><div class="line">　　alert(x); //0</div><div class="line">window.x === this.x //true</div></pre></td></tr></table></figure></p>
<h3 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：<strong>作为对象方法的调用</strong></h3><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　var o = &#123;&#125;;</div><div class="line">　　o.x = 1;</div><div class="line">　　o.m = test;</div><div class="line">　　o.m(); // 1</div></pre></td></tr></table></figure></p>
<h3 id="情况三-作为构造函数调用"><a href="#情况三-作为构造函数调用" class="headerlink" title="情况三 作为构造函数调用"></a>情况三 <strong>作为构造函数调用</strong></h3><p>所谓构造函数，就是通过这个函数生成一个实例对象（object）。这时，this就指这个实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 1;</div><div class="line">　　&#125;</div><div class="line">　　var o = new test();</div><div class="line">　　alert(o.x); // 1</div></pre></td></tr></table></figure></p>
<p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　var x = 2;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 1;</div><div class="line">　　&#125;</div><div class="line">　　var o = new test();</div><div class="line">　　alert(x); //2</div></pre></td></tr></table></figure></p>
<p>运行结果为2，表明全局变量x的值根本没变。</p>
<h3 id="情况四-apply调用"><a href="#情况四-apply调用" class="headerlink" title="情况四 apply调用"></a><strong>情况四 apply调用</strong></h3><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　var x = 0;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　var o=&#123;&#125;;</div><div class="line">　　o.x = 1;</div><div class="line">　　o.m = test;</div><div class="line">　　o.m.apply(); //0</div></pre></td></tr></table></figure></p>
<p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指向的是全局对象。<br>如果把最后一行代码修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　o.m.apply(o); //1</div></pre></td></tr></table></figure></p>
<p>运行结果就变成了1，证明了这时this指向的是对象o。</p>
<h2 id="二、apply、call、bind方法"><a href="#二、apply、call、bind方法" class="headerlink" title="二、apply、call、bind方法"></a>二、apply、call、bind方法</h2><h3 id="1-apply-amp-call"><a href="#1-apply-amp-call" class="headerlink" title="1.apply()&amp;call()"></a>1.apply()&amp;call()</h3><ul>
<li>作用：<br>call和apply都是为了改变某个函数运行时的上下文(context)而存在的，也就是改变this的指向;Javascript中函数有「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。<br>栗子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   function Foo(animal)&#123;</div><div class="line">       this.animal = animal;</div><div class="line">   &#125;</div><div class="line">   Foo.prototype.say = function()&#123;</div><div class="line">       console.log(this.animal);</div><div class="line">   &#125;;</div><div class="line">   var obj1 = new Foo(&apos;cat&apos;);</div><div class="line">   obj1.say();//cat</div><div class="line"></div><div class="line">   obj2 = &#123;animal:&apos;dog&apos;&#125;;</div><div class="line">   //obj2.say();//报错，因obj2没有定义say方法</div><div class="line">   obj1.say.call(obj2);//dog 调用obj1的say方法并改变this的指向</div><div class="line">obj1.say.apply(obj2);//dog</div></pre></td></tr></table></figure>
</li>
</ul>
<p>所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中obj2没有say方法），但是其他的有（本栗子中obj1有say方法），我们可以借助call或apply用其它对象的方法来操作。</p>
<ul>
<li><p>apply&amp;call的区别<br>其实就是接受的参数不同</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func.call(this,arg1,arg2,...);</div><div class="line">func.apply(this,[arg1,arg2,...]);</div></pre></td></tr></table></figure>
<p>  可以看出call的参数必须<strong>按顺序</strong>传递进去，而apply则是传递一个数组;<br>  JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。<br>  而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数。</p>
</li>
<li><p>apply&amp;call的常见用法</p>
<p>   <strong>数组之间追加</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr1 = [33,44,55,&#123;name:&apos;wayne&apos;&#125;];</div><div class="line">var arr2 = [88,99,22];</div><div class="line">Array.prototype.push.apply(arr1,arr2);</div><div class="line">	</div><div class="line">arr1// [33, 44, 55, Object, 88, 99, 22]</div></pre></td></tr></table></figure>
<p>   <strong>获取数组中的最大值和最小值</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//	number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</div><div class="line">var nums = [21,556,9,-200];</div><div class="line">var maxInNums = Math.max.apply(Math,nums);//556</div><div class="line">var minInNums = Math.min.apply(Math,nums);//-200</div></pre></td></tr></table></figure>
<p>   <strong>验证是否是数组（前提是toString()方法没有被重写过）</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">functionisArray(obj)&#123; </div><div class="line">   	return Object.prototype.toString.call(obj) === &apos;[object Array]&apos; ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   <strong>类（伪）数组使用数组方法</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。</div><div class="line">//但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</div><div class="line"></div><div class="line">var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-bind-方法"><a href="#2-bind-方法" class="headerlink" title="2.bind()方法"></a>2.bind()方法</h3><blockquote>
<p>MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 而我们可以利用bind()直接传入想要的上下文this</div><div class="line"></div><div class="line">var $box = $(&apos;.box&apos;);</div><div class="line">var foo = &#123;</div><div class="line">  animal: &apos;dog&apos;,</div><div class="line">  say_animal: function()&#123;</div><div class="line">    //var _this = this;</div><div class="line">    $box.on(&apos;click&apos;,function()&#123;</div><div class="line">      console.log(this.animal);</div><div class="line">    &#125;.bind(this));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">foo.say_animal();</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>三种方法的区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    x: 81,</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">var foo = &#123;</div><div class="line">    getX: function() &#123;</div><div class="line">        return this.x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(foo.getX.bind(obj)());  //81</div><div class="line">console.log(foo.getX.call(obj));    //81</div><div class="line">console.log(foo.getX.apply(obj));   //81</div></pre></td></tr></table></figure>
</li>
</ul>
<p>结论：区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p>
<ul>
<li>apply、call、bind都可以用来改变函数的this对象的指向;</li>
<li>apply、call、bind三者第一个参数都是this要指向的对象，也就是想指定的上下文;</li>
<li>apply、call、bind都可以利用后续参数传参;</li>
<li>bind返回对应函数，便于稍后调用;apply、call则是立即调用;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      总结this和改变this指向的方法
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="this" scheme="http://wayneblog.cn/tags/this/"/>
    
      <category term="apply" scheme="http://wayneblog.cn/tags/apply/"/>
    
      <category term="call" scheme="http://wayneblog.cn/tags/call/"/>
    
      <category term="bind" scheme="http://wayneblog.cn/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://wayneblog.cn/2016/07/02/git/"/>
    <id>http://wayneblog.cn/2016/07/02/git/</id>
    <published>2016-07-02T04:35:40.000Z</published>
    <updated>2016-12-05T04:08:15.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h3><ul>
<li><p>常用git bash命令操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git add </div><div class="line">$ git commit -m &quot;&quot;</div><div class="line">$ git status -sb//简略的描述当前的提交状态,显示分支信息和文件修改信息</div><div class="line">$ git diff xxx//告诉你修改前和修改后，标注修改的地方</div><div class="line">$ git log//查看历史提交</div><div class="line">$ git log --pretty=oneline//简略的查看历史提交</div><div class="line">$ git log --graph --pretty=online --abbrev-commit //可以看到</div><div class="line">$ git reset commitID//版本回退</div><div class="line">$ git reset --hard commitID//这里的commitID通过git reflog查看</div><div class="line">$ git reflog//查看命令历史</div><div class="line">$ git checkout -- xxx//撤销修改；注意中间的两条横杠一定要加，不加就是切换目录</div><div class="line">$ git rm xxx//在版本库删除文件</div><div class="line">$ git remote add origin SSH //可以将本地仓库关联远程仓库，只需要将SSH协议地址复制到那里</div><div class="line">$ git clone SSH //直接从远程版本库克隆到本地</div><div class="line">$ git branch //查看本地分支</div><div class="line">$ git branch -a //查看本地和远程的分支</div><div class="line">$ git pull //将远程版本库更新到本地版本库</div><div class="line">$ git checkout //切换分支</div><div class="line">$ git branch xx //创建分支xx</div><div class="line">$ git checkout -b xx //创建分支xx并切换到该分支</div><div class="line">$ git branch -d xx//本地删除xx分支，不会删除远程的分支</div><div class="line">$ git branch -D xx//强制删除xx分支，不管有没有合并</div><div class="line">$ git push origin :xx //删除远程xx分支</div><div class="line">$ git stash //暂时保存工作现场</div><div class="line">$ git stash list //将当前的git栈信息打印，所有工作现场都会有对应的版本号</div><div class="line">$ git stash apply stash@&#123;num&#125; //恢复到指定版本号</div><div class="line">$ git stash clear //将git栈清空</div><div class="line">$ git stash pop //恢复并清空</div></pre></td></tr></table></figure>
</li>
<li><p>常用命令行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ pwd ==&gt; process working directory当前所在目录 </div><div class="line">$ ls ==&gt; list </div><div class="line">$ ls -l ==&gt; list -long </div><div class="line">$ ls -a ==&gt; list -all </div><div class="line">$ ls -la === ls -l -a </div><div class="line">$ cat </div><div class="line">$ rm xxx//在工作区删除文件remove</div><div class="line">$ rm -r -f //r代表递归来删除文件夹下所有内容，f代表强制删除</div><div class="line">$ mkdir //make directory</div><div class="line">$ touch //</div><div class="line">$ cp xx1 xx2 //拷贝文件</div><div class="line">$ cp -r xx1 xx2 //拷贝文件夹</div><div class="line">$ mv xx1 xx2 //重命名</div><div class="line">$ head xx //显示前面十行</div><div class="line">$ head -n num xx //显示指定行数</div><div class="line">$ tail xx</div><div class="line">$ tail -n num xx</div><div class="line">$ echo //输入什么打印什么</div><div class="line">$ which xx//给出xx命令的所在地址</div><div class="line">$ sudo //最高权限super user do</div><div class="line">$ whoami //当前使用用户</div><div class="line">$ man ls //查看ls指令的文档</div><div class="line">$ tldr ls //查看ls的缩略文档</div><div class="line">$ $_  //上个输入的文件</div><div class="line">ctrl+A //光标移到最前</div><div class="line">ctrl+E //光标移到最后</div><div class="line">ctrl+K //把当前行删除</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h3><p>1.撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//在工作区直接修改，还没有添加到暂缓区</div><div class="line">$ git checkout -- xxx</div><div class="line">//在工作区修改后并添加到暂缓区</div><div class="line">$ git reset HEAD xxx  //先回退修改</div><div class="line">$ git checkout -- xxx  //再撤销修改 </div><div class="line">//在工作区没有修改直接添加到暂缓区后才修改了文件</div><div class="line">$ git checkout -- xxx</div><div class="line">//若是commit了的话</div><div class="line">$ git log --pretty=oneline  //先查看commit ID,复制需要回退到的id前六位</div><div class="line">$ git reset commitID</div><div class="line">$ git checkout -- xxx</div></pre></td></tr></table></figure></p>
<p>2.删除文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*删除文件*/</div><div class="line">$ rm xxx  //工作区常规删除xxx</div><div class="line">$ git status -sb //会告知工作区中xxx被删除了还没有重新add&amp;commit</div><div class="line">$ git rm xxx  //可以直接将仓库里的xxx也删除了</div><div class="line">$ git commit -m &quot;&quot;</div><div class="line">/*文件删错的操作*/</div><div class="line">$ rm xxx</div><div class="line">$ git checkout -- xxx  //说白了这个操作就是将版本库里的xxx替代工作区中的xxx，因此可以撤销修改也可以还原</div></pre></td></tr></table></figure></p>
<p>3.关于git push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//首次git push</div><div class="line">$ git push --set-upsteam origin master //或者</div><div class="line">$ git push -u origin master //这样设置后，以后都会自动匹配，后面就直接用git push来推送就行了</div></pre></td></tr></table></figure></p>
<p>4.创建新分支feature<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b xx //创建xx分支并切换到该分支</div><div class="line">$ touch xxx;vim xxx;git add xxx;git commit -m &quot;&quot;; //一系列修改并提交</div><div class="line">$ git push origin feature1:feature1 //推送到origin远程仓库，origin是远程版本库的默认名字，后面两个feature1前者是本地分支，后者是远程分支</div><div class="line">$ git checkout master; git merge feature1;// 回到master主分支并合并feature1分支</div><div class="line">$ git branch -d feature1; git push origin :feature1 //删除本地的feature1分支并且删除远处的feature1分支</div></pre></td></tr></table></figure></p>
<p>5.git pull时产生的冲突解决（属于与伙伴之间的远程冲突）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//当改的是同一个地方时，需要协商并作出更改</div><div class="line">$ git pull; git push //当修改完后提交，要是修改的是同一个地方的话这里git pull就会提醒merge conflick</div><div class="line">$ git status -sb //若显示UU，则冲突</div><div class="line">$ vim xxx //</div><div class="line">//本地冲突是&lt;&lt;&lt;和===之间，远程冲突是===和&gt;&gt;&gt;之间</div><div class="line">//git add;git commit</div><div class="line">//git push</div></pre></td></tr></table></figure></p>
<p>6.三种merge的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//第一种方式是Fast-forward，fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit</div><div class="line">$ git merge feature  //这种合并方式的话在log的graph看不到具体的合并</div><div class="line">//第二种是--no-ff，不使用fast-forward方式合并，保留分支的commit历史</div><div class="line">$ git merge --no-ff -m &quot;&quot; feature</div></pre></td></tr></table></figure></p>
<p><img src="/images/git/gitmerge.png" alt=""><br>7.修复Bug<br>工作分支dev工作至一半,保存现场<br><img src="/images/git/1.png" alt=""><br><img src="/images/git/2.png" alt=""><br><img src="/images/git/3.png" alt=""><br><img src="/images/git/4.png" alt=""><br><img src="/images/git/5.png" alt=""><br><img src="/images/git/6.png" alt=""><br><img src="/images/git/7.png" alt=""></p>
<p><a href="http://www.cppblog.com/deercoder/archive/2011/11/13/160007.aspx" target="_blank" rel="external">关于为什么要用git stash</a></p>
]]></content>
    
    <summary type="html">
    
      自己总结的常用的git命令实际应用
    
    </summary>
    
      <category term="个人总结" scheme="http://wayneblog.cn/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="git" scheme="http://wayneblog.cn/tags/git/"/>
    
  </entry>
  
</feed>
