<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wayne&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wayneblog.cn/"/>
  <updated>2016-12-02T13:47:32.923Z</updated>
  <id>http://wayneblog.cn/</id>
  
  <author>
    <name>Wayne Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>server mock</title>
    <link href="http://wayneblog.cn/2016/12/02/server-mock/"/>
    <id>http://wayneblog.cn/2016/12/02/server-mock/</id>
    <published>2016-12-02T08:35:09.000Z</published>
    <updated>2016-12-02T13:47:32.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、nodejs服务器"><a href="#一、nodejs服务器" class="headerlink" title="一、nodejs服务器"></a>一、nodejs服务器</h2><ol>
<li>为什么要有mock？<br>因为前端在发请求给后端的时候是依赖于后端的响应的，没有得到响应无法进行下一步，所以我们要想方设法自己模拟返回的数据，这个过程就叫做mock；</li>
<li>我们的本地IP是127.0.0.1</li>
<li>server服务器必须监听本地端口，server.listen(‘8888’)</li>
<li><p>要想创建http服务器，须先引用server模块，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>正常的网页返回的是文件而不是字符串，所以我们为了返回文件引入了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;) //nodejs内置的文件系统file system</div></pre></td></tr></table></figure>
</li>
<li><p>用http的createServer创建一个http服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var server = http.createServer(function(request,response)&#123;</div><div class="line">    response.writeHead(200);//返回的状态码</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>fs的readFile方法可以读文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;index.html&apos;,function(error,content)&#123;</div><div class="line">        //因为是回调函数所以必须在readFile后才会触发</div><div class="line">        //正因如此我们必须把返回的结果也放进来，要是放在函数外面的话，可能还没读完文件就赋值了会undefined</div><div class="line">        var fileContent = content.toString();//默认的content是二进制的格式</div><div class="line">        response.end(fileContent);//这是响应的内容</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>nodejs的核心就是理解请求和响应</p>
</li>
<li>默认响应给浏览器的有response.end()还有favicon，我们需要将favicon变成404，即用url来区分</li>
<li>request.method可以知道是用GET请求还是POST请求</li>
<li>整个过程就是，浏览器发送请求给服务器，服务器必须监听了跟浏览器同样的端口才能接收请求并作出响应；服务器会跟句request的需求返回对应的响应，一个请求对应一个响应，不能对应多个响应；</li>
<li>request包括url， response包括状态码+字符串</li>
</ol>
<p><img src="/images/server-mock/server_mock1.jpeg" alt=""><br><img src="/images/server-mock/server_mock2.jpeg" alt=""><br><img src="/images/server-mock/server_mock3.jpeg" alt=""><br><img src="/images/server-mock/server_mock4.jpeg" alt=""><br><img src="/images/server-mock/server_mock5.jpeg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      自己总结的mock数据的方法
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="server" scheme="http://wayneblog.cn/tags/server/"/>
    
      <category term="mock" scheme="http://wayneblog.cn/tags/mock/"/>
    
      <category term="ajax" scheme="http://wayneblog.cn/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://wayneblog.cn/2016/07/02/git/"/>
    <id>http://wayneblog.cn/2016/07/02/git/</id>
    <published>2016-07-02T04:35:40.000Z</published>
    <updated>2016-12-05T04:08:15.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h3><ul>
<li><p>常用git bash命令操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git add </div><div class="line">$ git commit -m &quot;&quot;</div><div class="line">$ git status -sb//简略的描述当前的提交状态,显示分支信息和文件修改信息</div><div class="line">$ git diff xxx//告诉你修改前和修改后，标注修改的地方</div><div class="line">$ git log//查看历史提交</div><div class="line">$ git log --pretty=oneline//简略的查看历史提交</div><div class="line">$ git log --graph --pretty=online --abbrev-commit //可以看到</div><div class="line">$ git reset commitID//版本回退</div><div class="line">$ git reset --hard commitID//这里的commitID通过git reflog查看</div><div class="line">$ git reflog//查看命令历史</div><div class="line">$ git checkout -- xxx//撤销修改；注意中间的两条横杠一定要加，不加就是切换目录</div><div class="line">$ git rm xxx//在版本库删除文件</div><div class="line">$ git remote add origin SSH //可以将本地仓库关联远程仓库，只需要将SSH协议地址复制到那里</div><div class="line">$ git clone SSH //直接从远程版本库克隆到本地</div><div class="line">$ git branch //查看本地分支</div><div class="line">$ git branch -a //查看本地和远程的分支</div><div class="line">$ git pull //将远程版本库更新到本地版本库</div><div class="line">$ git checkout //切换分支</div><div class="line">$ git branch xx //创建分支xx</div><div class="line">$ git checkout -b xx //创建分支xx并切换到该分支</div><div class="line">$ git branch -d xx//本地删除xx分支，不会删除远程的分支</div><div class="line">$ git branch -D xx//强制删除xx分支，不管有没有合并</div><div class="line">$ git push origin :xx //删除远程xx分支</div><div class="line">$ git stash //暂时保存工作现场</div><div class="line">$ git stash list //将当前的git栈信息打印，所有工作现场都会有对应的版本号</div><div class="line">$ git stash apply stash@&#123;num&#125; //恢复到指定版本号</div><div class="line">$ git stash clear //将git栈清空</div><div class="line">$ git stash pop //恢复并清空</div></pre></td></tr></table></figure>
</li>
<li><p>常用命令行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ pwd ==&gt; process working directory当前所在目录 </div><div class="line">$ ls ==&gt; list </div><div class="line">$ ls -l ==&gt; list -long </div><div class="line">$ ls -a ==&gt; list -all </div><div class="line">$ ls -la === ls -l -a </div><div class="line">$ cat </div><div class="line">$ rm xxx//在工作区删除文件remove</div><div class="line">$ rm -r -f //r代表递归来删除文件夹下所有内容，f代表强制删除</div><div class="line">$ mkdir //make directory</div><div class="line">$ touch //</div><div class="line">$ cp xx1 xx2 //拷贝文件</div><div class="line">$ cp -r xx1 xx2 //拷贝文件夹</div><div class="line">$ mv xx1 xx2 //重命名</div><div class="line">$ head xx //显示前面十行</div><div class="line">$ head -n num xx //显示指定行数</div><div class="line">$ tail xx</div><div class="line">$ tail -n num xx</div><div class="line">$ echo //输入什么打印什么</div><div class="line">$ which xx//给出xx命令的所在地址</div><div class="line">$ sudo //最高权限super user do</div><div class="line">$ whoami //当前使用用户</div><div class="line">$ man ls //查看ls指令的文档</div><div class="line">$ tldr ls //查看ls的缩略文档</div><div class="line">$ $_  //上个输入的文件</div><div class="line">ctrl+A //光标移到最前</div><div class="line">ctrl+E //光标移到最后</div><div class="line">ctrl+K //把当前行删除</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h3><p>1.撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//在工作区直接修改，还没有添加到暂缓区</div><div class="line">$ git checkout -- xxx</div><div class="line">//在工作区修改后并添加到暂缓区</div><div class="line">$ git reset HEAD xxx  //先回退修改</div><div class="line">$ git checkout -- xxx  //再撤销修改 </div><div class="line">//在工作区没有修改直接添加到暂缓区后才修改了文件</div><div class="line">$ git checkout -- xxx</div><div class="line">//若是commit了的话</div><div class="line">$ git log --pretty=oneline  //先查看commit ID,复制需要回退到的id前六位</div><div class="line">$ git reset commitID</div><div class="line">$ git checkout -- xxx</div></pre></td></tr></table></figure></p>
<p>2.删除文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*删除文件*/</div><div class="line">$ rm xxx  //工作区常规删除xxx</div><div class="line">$ git status -sb //会告知工作区中xxx被删除了还没有重新add&amp;commit</div><div class="line">$ git rm xxx  //可以直接将仓库里的xxx也删除了</div><div class="line">$ git commit -m &quot;&quot;</div><div class="line">/*文件删错的操作*/</div><div class="line">$ rm xxx</div><div class="line">$ git checkout -- xxx  //说白了这个操作就是将版本库里的xxx替代工作区中的xxx，因此可以撤销修改也可以还原</div></pre></td></tr></table></figure></p>
<p>3.关于git push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//首次git push</div><div class="line">$ git push --set-upsteam origin master //或者</div><div class="line">$ git push -u origin master //这样设置后，以后都会自动匹配，后面就直接用git push来推送就行了</div></pre></td></tr></table></figure></p>
<p>4.创建新分支feature<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b xx //创建xx分支并切换到该分支</div><div class="line">$ touch xxx;vim xxx;git add xxx;git commit -m &quot;&quot;; //一系列修改并提交</div><div class="line">$ git push origin feature1:feature1 //推送到origin远程仓库，origin是远程版本库的默认名字，后面两个feature1前者是本地分支，后者是远程分支</div><div class="line">$ git checkout master; git merge feature1;// 回到master主分支并合并feature1分支</div><div class="line">$ git branch -d feature1; git push origin :feature1 //删除本地的feature1分支并且删除远处的feature1分支</div></pre></td></tr></table></figure></p>
<p>5.git pull时产生的冲突解决（属于与伙伴之间的远程冲突）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//当改的是同一个地方时，需要协商并作出更改</div><div class="line">$ git pull; git push //当修改完后提交，要是修改的是同一个地方的话这里git pull就会提醒merge conflick</div><div class="line">$ git status -sb //若显示UU，则冲突</div><div class="line">$ vim xxx //</div><div class="line">//本地冲突是&lt;&lt;&lt;和===之间，远程冲突是===和&gt;&gt;&gt;之间</div><div class="line">//git add;git commit</div><div class="line">//git push</div></pre></td></tr></table></figure></p>
<p>6.三种merge的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//第一种方式是Fast-forward，fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit</div><div class="line">$ git merge feature  //这种合并方式的话在log的graph看不到具体的合并</div><div class="line">//第二种是--no-ff，不使用fast-forward方式合并，保留分支的commit历史</div><div class="line">$ git merge --no-ff -m &quot;&quot; feature</div></pre></td></tr></table></figure></p>
<p><img src="/images/git/gitmerge.png" alt=""><br>7.修复Bug<br>工作分支dev工作至一半,保存现场<br><img src="/images/git/1.png" alt=""><br><img src="/images/git/2.png" alt=""><br><img src="/images/git/3.png" alt=""><br><img src="/images/git/4.png" alt=""><br><img src="/images/git/5.png" alt=""><br><img src="/images/git/6.png" alt=""><br><img src="/images/git/7.png" alt=""></p>
<p><a href="http://www.cppblog.com/deercoder/archive/2011/11/13/160007.aspx" target="_blank" rel="external">关于为什么要用git stash</a></p>
]]></content>
    
    <summary type="html">
    
      自己总结的常用的git命令实际应用
    
    </summary>
    
      <category term="个人总结" scheme="http://wayneblog.cn/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="git" scheme="http://wayneblog.cn/tags/git/"/>
    
  </entry>
  
</feed>
