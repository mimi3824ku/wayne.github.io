<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wayne&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wayneblog.cn/"/>
  <updated>2017-02-06T10:39:05.203Z</updated>
  <id>http://wayneblog.cn/</id>
  
  <author>
    <name>Wayne Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript事件总结</title>
    <link href="http://wayneblog.cn/2016/12/30/Javascript-event/"/>
    <id>http://wayneblog.cn/2016/12/30/Javascript-event/</id>
    <published>2016-12-30T04:35:20.000Z</published>
    <updated>2017-02-06T10:39:05.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>个人认为：不论是浏览器自带的事件，还是自定义事件，都是观察者模式的实现。更确切地说：事件流是会流动的，流到哪个节点，事件在哪里发生，事件发生时，节点便会调用在这个节点绑定的事件处理程序。节点是被观察者，事件处理程序是观察者，当事件流流到被观察者时，被观察者会对外宣称“我这里发生了某个事件”，即通知观察者，也就是节点调用事件处理程序。事件流是不知道被观察者有多少个的，所以即使是0个，事件流也会继续流，流到节点时，节点会遍历自己注册的事件处理程序，存在就调用。具体浏览器的实现和优化肯定更加复杂和精妙，但原理应该是这样（以上为个人理解）。</p>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>事件流分为事件冒泡和事件捕获：</p>
<blockquote>
<ul>
<li>如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。在浏览器上单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。事件流描述的是从页面中接收事件的顺序。</li>
<li>IE开发团队提出了事件冒泡流、Netscape开发团队提出了事件捕获流。</li>
</ul>
</blockquote>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><blockquote>
<ul>
<li>事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点，所有现代浏览器都支持事件冒泡，除IE5.5外，均一直冒泡到window。</li>
<li>事件冒泡示意图：<br><img src="http://i1.piimg.com/567571/8a3af36c8bc7d090.png" alt=""></li>
</ul>
</blockquote>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><blockquote>
<ul>
<li>不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。IE9+、Safari、Chrome、Opera和Firefox支持，且从window开始捕获（尽管DOM2 级事件规范要求从document）</li>
<li>事件捕获示意图：<br><img src="http://i1.piimg.com/567571/f51d8dbcd0d5b373.png" alt=""></li>
<li>由于老版本的浏览器不支持，因此很少有人使用事件捕获。我们也建议读者放心地使用事件冒泡，在有特殊需要时再使用事件捕获。</li>
</ul>
</blockquote>
<ul>
<li>为了彻底理解事件冒泡和捕获，这里写了个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=&quot;a&quot;&gt;</div><div class="line">		&lt;div id=&quot;b&quot;&gt;</div><div class="line">			&lt;div id=&quot;c&quot;&gt;&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;script src=&quot;test1.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//test1.css</div><div class="line">#a&#123;</div><div class="line">	width: 300px;</div><div class="line">	height: 300px;</div><div class="line">	background: pink;</div><div class="line">&#125;</div><div class="line">#b&#123;</div><div class="line">	width: 200px;</div><div class="line">	height: 200px;</div><div class="line">	background: blue;</div><div class="line">&#125;</div><div class="line">#c&#123;</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	background: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//test1.js</div><div class="line">var a = document.getElementById(&quot;a&quot;),</div><div class="line">	b = document.getElementById(&quot;b&quot;),</div><div class="line">	c = document.getElementById(&quot;c&quot;);</div><div class="line">	c.addEventListener(&quot;click&quot;, function(event)&#123;</div><div class="line">	console.log(&quot;c1&quot;)</div><div class="line">	// 注意第三个参数没有传进 false , 因为默认传进来的是 false，代表冒泡阶段调用，个人认为处于目标阶段也会调用的</div><div class="line">	&#125;);</div><div class="line">	c.addEventListener(&quot;click&quot;, function(event)&#123;</div><div class="line">		console.log(&quot;c2&quot;);</div><div class="line">	&#125;, true);</div><div class="line">	b.addEventListener(&quot;click&quot;, function(event)&#123;</div><div class="line">		console.log(&quot;b&quot;);</div><div class="line">	&#125;, true);</div><div class="line">	a.addEventListener(&quot;click&quot;, function(event)&#123;</div><div class="line">		console.log(&quot;a1&quot;);</div><div class="line">	&#125;, true);</div><div class="line">	a.addEventListener(&quot;click&quot;, function(event)&#123;</div><div class="line">		console.log(&quot;a2&quot;)</div><div class="line">	&#125;);</div><div class="line">	a.addEventListener(&quot;click&quot;, function(event)&#123;</div><div class="line">		console.log(&quot;a3&quot;);</div><div class="line">		event.stopImmediatePropagation();</div><div class="line">	&#125;, true);</div><div class="line">a.addEventListener(&quot;click&quot;, function(event)&#123;</div><div class="line">console.log(&quot;a4&quot;);</div><div class="line">&#125;, true);</div></pre></td></tr></table></figure>
<ul>
<li>效果图</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/2ac062602fdca7a7.png" alt=""></p>
<ul>
<li><strong>点击 c 或 b，输出：a1、a3</strong></li>
<li>stopImmediatePropagation 包含了 stopPropagation 的功能，即阻止事件传播（捕获或冒泡），但<strong>同时也阻止该元素上后来绑定的事件处理程序被调用</strong>，所以不输出 a4，因为事件捕获被拦截了，自然不会触发 b、c 上的事件，所以不输出 b、c1、c2，冒泡更谈不上了，所以不输出 a2。有人会觉得上面的表述有一点点问题，为什么捕获被拦截了，c1 就不输出了呢？ c1 应该是冒泡阶段被调用的呀，所以应该改为另一个表述：“…冒泡更谈不上，所以不输出 c1、a2”。但另一个表述是错的，下面会分析到。</li>
<li><strong>点击 a，输出 a1、a2、a3</strong></li>
<li>不应该是 a1、a3、a2 吗？a1、a3 可是在捕获阶段被调用的处理程序啊，a2 是在冒泡阶段被调用的啊。这里正是要说明的：虽然这三个事件处理程序注册时指定了true、false，但现在事件流是处于目标阶段，不是冒泡阶段、也不是捕获阶段，事件处理程序被调用的顺序是注册的顺序。不论你指定的是 true or false. 这也解释了上面提到的“另一种表述”为什么是错误的。</li>
<li>更深一步解释是：要区分事件流和事件处理程序，不论事件处理程序存不存在，事件流都会传播。这是一个观察者模式，绑定事件的节点是被观察者、事件处理程序是观察者，事件流是不知道观察者的存在的，所以你点击页面的时候，事件流一定要传播，传播到某一个节点时，节点去通知所有观察者，也就是调用事件处理程序（有可能观察者不存在）。</li>
<li>当一个事件流来到一个节点时，事件流可能在捕获阶段（正在流向最深层次的节点）、可能在处于目标阶段（已经流到了目标，也就是event.target）、也可能在冒泡阶段（正在流向最外层节点）。而事件处理程序是这么处理的：<strong>① 注册时第三个参数指定为 true 时，事件流到来，如果事件流是捕获阶段或处于目标阶段，则调用该事件处理程序。②注册时第三个参数指定为 false 时，当事件流到来，如果事件流是处于目标阶段或冒泡阶段，则调用该事件处理程序。</strong></li>
<li>注释掉 event.stopImmediatePropagation，点击 c，输出 a1、a3、a4、b、c1、c2、a2</li>
<li>另外，如果同一个事件处理程序（指针相同，比如用 handler 保存的事件处理程序），用 addEventListener 或 attachEvent 绑定多次，如果第三个参数是相同的话，也只会被调用一次。但如果第三个参数一个设置为true，另一个设置为false，那么会被调用两次。</li>
</ul>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><blockquote>
<ul>
<li>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段。（事件处理中“处于目标阶段”被看成冒泡阶段的一部分）。</li>
<li>IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件，就是有两个机会在目标对象上面操作事件。（尽管DOM2级事件规范明确要求捕获阶段不涉及事件目标）。</li>
</ul>
</blockquote>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><blockquote>
<ul>
<li>每个元素（包括window 和document）都有自己的事件处理程序属性，这些属性<strong>通常全部小写</strong>。使用 DOM0 级指定的事件处理程序被认为是元素的方法。this 引用当前元素。通过 this 可以访问元素的任何属性和方法(但经过测试，class、自定义属性不能直接访问，通过 [] 访问也不行，id、value、type 这种可以)。DOM0 级事件处理程序在冒泡阶段被处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;myBtn&quot;);</div><div class="line">btn.onclick = function () &#123;</div><div class="line">    alert(this.id); //&quot;myBtn&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><blockquote>
<ul>
<li><code>addEventListener()</code> 包含三个参数，要处理的事件名、事件处理函数、布尔值，布尔值为true，表示在捕获阶段调用事件处理程序，反之在冒泡阶段调用。</li>
<li>DOM2 级事件处理程序中的 this 也指向 <code>addEventListener</code> 的那个元素。</li>
<li><p>可以添加多个事件处理程序，按添加顺序依次调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//removeEventListener 无法移除匿名函数的事件处理程序。</div><div class="line">var btn = document.getElementById(&quot;myBtn&quot;);</div><div class="line">var handler = function () &#123;</div><div class="line">   alert(this.id);</div><div class="line">&#125;;</div><div class="line">btn.addEventListener(&quot;click&quot;, handler, false);</div><div class="line">//这里省略了其他代码</div><div class="line">btn.removeEventListener(&quot;click&quot;, handler, false); // 有效！</div></pre></td></tr></table></figure>
</li>
<li><p>IE9、Firefox、Safari、Chrome 和Opera 支持DOM2 级事件处理程序。</p>
</li>
</ul>
</blockquote>
<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><blockquote>
<ul>
<li><code>attachEvent</code> <code>detachEvent</code> 接收两个参数，事件处理程序名称、事件处理程序函数。由于IE8及更早版本只支持事件冒泡，所以该事件处理程序只支持事件冒泡。</li>
<li>老版本的Opera支持这种方法，但现在Opera已经改用blink内核，IE11已经不支持这种方法，注意 IE9 就已经支持 DOM2 级事件处理程序了。</li>
<li>特别要注意：第一个参数包含on，比如onclick。</li>
<li>区别于DOM0 级事件处理程序，<code>this</code> 指向 ‘window’。</li>
<li>也可以添加多个事件处理程序。</li>
</ul>
</blockquote>
<h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">    addHandler: function(element, type, handler)&#123;</div><div class="line">        if (element.addEventListener)&#123;</div><div class="line">            element.addEventListener(type, handler, false);</div><div class="line">        &#125; else if (element.attachEvent)&#123;</div><div class="line">            element.attachEvent(&quot;on&quot; + type, handler);</div><div class="line">        &#125; else &#123;</div><div class="line">            element[&quot;on&quot; + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    removeHandler: function(element, type, handler)&#123;</div><div class="line">        if (element.removeEventListener)&#123;</div><div class="line">            element.removeEventListener(type, handler, false);</div><div class="line">        &#125; else if (element.detachEvent)&#123;</div><div class="line">            element.detachEvent(&quot;on&quot; + type, handler);</div><div class="line">        &#125; else &#123;</div><div class="line">            element[&quot;on&quot; + type] = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>存在问题：</li>
</ul>
<ol>
<li>IE事件处理程序 中的 this 指向 window。</li>
<li>只支持 DOM0 级的浏览器不能多次添加事件处理程序，不过这种浏览器应该不多了，即使是IE8 也支持attachEvent。</li>
<li>会不会有一些事件，在浏览器支持 DOM2 级事件处理程序的情况下，那些事件只能用 on + name 的形式呢？ 之前一直怀疑 (1).xhr.onreadystatechange() 和 (2).DOMNodeInserted 事件，这里我多虑了，经过验证，(1).是支持 DOM2 级事件的，(2).天生就是 DOM2 级的，而且也支持 DOM0 事件处理程序。这里只是为了打消我的疑虑，记录下来。</li>
</ol>
</blockquote>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><h3 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h3><blockquote>
<ul>
<li>兼容 DOM 的浏览器会将一个 event 对象传入事件处理程序， IE9 及更高版本可以，无论指定事件处理程序时使用什么方法（DOM0 级 DOM2 级），HTML 事件处理程序可以通过访问 event 变量得到 event 对象。</li>
<li>event 中的属性和方法都是只读的</li>
<li>常用属性：</li>
</ul>
<ol>
<li><code>target</code> 事件的目标</li>
<li><code>currentTarget</code> 绑定事件的元素，与 ‘this’ 的指向相同</li>
<li><code>stopPropagation()</code> 取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法</li>
<li><code>stopImmediatePropagation()</code> 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增）（这个说法不大准确，应该是<strong>阻止比该事件处理程序后注册的事件处理程序执行</strong>）</li>
<li><code>preventDefault()</code> 取消事件的默认行为，比如点击链接跳转。如果 cancelable 是 true，则可以使用这个方法</li>
<li><code>type</code> 被触发的事件类型</li>
<li><code>eventPhase</code> 调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段</li>
</ol>
</blockquote>
<pre><code>//this target currentTarget 举例：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">document.body.onclick = function(event)&#123;</div><div class="line">    alert(event.currentTarget === document.body); //true</div><div class="line">    alert(this === document.body); //true</div><div class="line">    alert(event.target === document.getElementById(&quot;myBtn&quot;)); //true</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>通过 <code>event.type</code> 与 <code>switch case</code> 组合，可以通过一个函数处理多个事件。</li>
<li>只有在事件处理程序执行期间，<code>event</code> 对象才会存在；一旦事件处理程序执行完成，<code>event</code> 对象就会被销毁。</li>
</ul>
</blockquote>
<h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><blockquote>
<ul>
<li>DOM0 级的事件处理程序，event 作为 window 的一个属性存在。（从 IE9 开始，event 可以从参数中获得）</li>
<li><code>attachEvent</code> 添加的事件处理程序，<code>event</code> 作为参数传入，也可以通过 <code>window</code> 来访问 <code>event</code> 对象。</li>
<li>HTML 事件处理程序依然可以通过访问 <code>event</code> 变量得到 <code>event</code> 对象。</li>
<li>属性和方法：</li>
</ul>
<ol>
<li><code>cancelBubble</code> 设置 <code>true</code> 可以取消事件冒泡</li>
<li><code>returnValue</code> 设置 <code>false</code> 可以取消事件的默认行为。</li>
<li><code>srcElement</code> 事件的目标（与DOM中的 <code>target</code> 相同）</li>
</ol>
<ul>
<li>注意事项：</li>
</ul>
<ol>
<li><code>attachEvent</code> 中的 <code>event.srcElement === this</code> 吗？ 答案是否定的，因为前面说到过 <code>attachEvent</code> 中 <code>this</code> 指向 <code>window</code>, DOM0 级、DOM2 级 事件处理程序 <code>this</code> 才指向 <code>event.target / window.event.srcElement</code></li>
</ol>
</blockquote>
<h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line"> getEvent: function(event)&#123;</div><div class="line">   return event ? event : window.event; // window.event DOM0级时IE</div><div class="line">   &#125;,</div><div class="line"> getTarget: function(event)&#123;</div><div class="line">   return event.target || event.srcElement; // event.srcElement for IE</div><div class="line">  &#125;,</div><div class="line"> preventDefault: function(event)&#123;</div><div class="line">   if (event.preventDefault)&#123;</div><div class="line">   event.preventDefault();</div><div class="line">  &#125; else &#123;</div><div class="line">   event.returnValue = false; // IE</div><div class="line">   &#125;</div><div class="line">  &#125;,</div><div class="line">  stopPropagation: function(event)&#123;</div><div class="line">   if (event.stopPropagation)&#123;</div><div class="line">   event.stopPropagation();</div><div class="line">  &#125; else &#123;</div><div class="line">   event.cancelBubble = true; // IE</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><blockquote>
<ul>
<li>DOM3 级事件规定了几类事件；HTML5 也定义了一组事件；还有一些事件没有规范，浏览器的实现不一致。</li>
<li>DOM3 级事件模块在 DOM2 级事件模块基础上重新定义了这些事件，也添加了一些新事件。包括 IE9 在内的所有主流浏览器都支持 DOM2 级事件。IE9 也支持 DOM3 级事件。</li>
</ul>
</blockquote>
<h3 id="UI事件类型"><a href="#UI事件类型" class="headerlink" title="UI事件类型"></a>UI事件类型</h3><blockquote>
<ul>
<li><p>load 事件，当页面完全加载后（包括所有图像、JavaScript 文件、CSS 文件等外部资源），就会触发 window 上面的 load 事件。</p>
</li>
<li><p>resize 事件</p>
</li>
</ul>
<ol>
<li>浏览器窗口大小发生变化时会触发该事件，这个事件在 window 上触发，IE、Safari、Chrome 和 Opera 会在浏览器窗口变化了 1 像素时就触发 resize 事件，然后随着变化不断重复触发。Firefox 则只会在用户停止调整窗口大小时才会触发。</li>
<li>注意不要在这个事件的处理程序中加入大计算量的代码，或者采用函数节流的方式优化性能。</li>
<li>浏览器窗口最小化或最大化时也会触发 resize 事件。</li>
</ol>
<ul>
<li>scroll 事件</li>
</ul>
<ol>
<li>该事件在 window 上发生，此处和书上讲的有点不一样，webkit 内核或 blink 内核的浏览器（Chrome、Opera、Safari）可以通过 <code>document.body.scrollTop</code> 获取页面被卷去的高度，而 Trident、Gecko （IE、火狐）可以通过 <code>document.documentElement.scrollTop</code>来获取该值。</li>
<li>所以最好通过 <code>document.body.scrollTop + document.documentElement.scrollTop</code> 的方式获取 scrollTop 的值，因为两者之一会等于0，或者使用 <code>document.body.scrollTop || document.documentElement.scrollTop</code>，两者效果一致。</li>
<li>发现普通元素，指定 scroll 的处理程序，通过 <code>event.target.scrollTop</code> 也是可以取得相应的值，兼容性没测试，用的时候注意一下。</li>
</ol>
</blockquote>
<h3 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h3><blockquote>
<ul>
<li><code>click</code> 在用户单击住鼠标按钮或按下回车键时触发。 触发顺序 mousedown mouseup click，如果 mousedown、mouseup 其中之一被取消，就不会触发 click 事件。</li>
<li><code>dblclick</code> 触发顺序 mousedown mouseup click mousedown mouseup click dblclick， 如果中间有事件被取消，dblclick 也不会被触发</li>
<li><code>mousedown</code> 用户按下了任意鼠标按钮时触发。</li>
<li><code>mouseup</code> 用户释放按钮时触发</li>
<li><code>mouseenter</code> 在鼠标光标从元素外部首次移动到元素范围之内时触发。不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事，但 DOM3 级事件将它纳入了规范。IE、Firefox9+和Opera支持这个事件。</li>
<li><code>mouseleave</code> 在位于元素上方的鼠标光标移动到元素范围之外时触发。不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事，但 DOM3 级事件将它纳入了规范。IE、Firefox9+ 和 Opera 支持这个事件。</li>
<li><code>mouseover</code> 在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。</li>
<li><code>mouseout</code> 在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。</li>
</ul>
</blockquote>
<p>mouseenter、mouseleave 和 mouseover、mouseout 的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;zh-cn&quot;&gt;</div><div class="line"> &lt;head&gt;</div><div class="line">  &lt;title&gt;test1&lt;/title&gt;</div><div class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test1.css&quot;&gt;</div><div class="line"> &lt;/head&gt;</div><div class="line"> &lt;body&gt;</div><div class="line">  &lt;div class=&quot;mouseover&quot;&gt;</div><div class="line">   &lt;div class=&quot;sub-mouseover&quot;&gt;</div><div class="line">   &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;div class=&quot;mouseenter&quot;&gt;</div><div class="line">   	&lt;div class=&quot;sub-mouseenter&quot;&gt;</div><div class="line">   	&lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">   	&lt;script src=&quot;test1.js&quot;&gt;&lt;/script&gt;</div><div class="line"> &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">   </div><div class="line">//test1.css</div><div class="line">   .wrap &#123;</div><div class="line">   	width: 200px;</div><div class="line">   	height: 100px;</div><div class="line">   &#125;</div><div class="line">   .mouseover &#123;</div><div class="line">   	background: pink;</div><div class="line">   &#125;</div><div class="line">   .mouseenter &#123;</div><div class="line">   	margin-top: 30px;</div><div class="line">   	background: gray;</div><div class="line">   &#125;</div><div class="line">   .sub-mouseover,</div><div class="line">   .sub-mouseenter &#123;</div><div class="line">   	width: 100px;</div><div class="line">   	height: 50px;</div><div class="line">   	background: #AE81FF;</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">//test1.js</div><div class="line">   var div1 = document.querySelector(&quot;.mouseover&quot;),</div><div class="line">   	div2 = document.querySelector(&quot;.mouseenter&quot;);</div><div class="line">   div1.addEventListener(&quot;mouseover&quot;, function()&#123;</div><div class="line">   	console.log(&quot;div1 mouseover&quot;);</div><div class="line">   &#125;);</div><div class="line">   div1.addEventListener(&quot;mouseout&quot;, function()&#123;</div><div class="line">   	console.log(&quot;div1 mouseout&quot;);</div><div class="line">   &#125;)</div><div class="line">   div2.addEventListener(&quot;mouseenter&quot;, function()&#123;</div><div class="line">   	console.log(&quot;div2 mouseenter&quot;);</div><div class="line">   &#125;)</div><div class="line">   div2.addEventListener(&quot;mouseleave&quot;, function()&#123;</div><div class="line">   	console.log(&quot;div2 mouseleave&quot;);</div><div class="line">   &#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p>效果图<br><img src="http://i1.piimg.com/567571/e19b404e62fbc140.png" alt=""></p>
</li>
<li><p>鼠标由左侧从上到下依次经过所有 div 的情况，输出 <code>div1 mouseover</code> <code>div1 mouseout</code> <code>div1 mouseover</code> <code>div1 mouseout</code> <code>div2 mouseenter</code> <code>div2 mouseleave</code></p>
</li>
</ul>
<blockquote>
<ul>
<li><code>mousemove</code> 当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。</li>
<li>除了 <code>mouseenter</code>、<code>mousedleave</code>，所有鼠标事件都会冒泡，取消鼠标事件将会影响浏览器的默认行为，也会影响其它事件，因为鼠标事件与其它事件是密不可分的。</li>
<li>关于 <code>dblclick</code> IE8 及之前版本中的实现有一个小bug，因此在双击事件中，会跳过第二个<code>mousedown</code> 和click事件，其顺序如下：<code>mousedown</code> <code>mouseup</code> <code>click</code> <code>mouseup</code> <code>dblclick</code>，但还是会触发 <code>dblclick</code> 事件</li>
<li>客户区坐标位置：鼠标事件中的 event 都有 clientX clientY 属性，表示在视口中客户区的坐标位置，这些值不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置：<br><img src="http://p1.bpimg.com/567571/4737369b32025045.png" alt=""></li>
</ul>
</blockquote>
<ul>
<li>页面坐标位置：pageX、pageY，这两个属性表示鼠标光标在页面中的位置，在页面<strong>没有滚动</strong>的情况下，pageX 和 pageY 的值与 clientX、clientY 的值相等。IE8 及更早版本不支持事件对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出来。</li>
</ul>
<blockquote>
<ul>
<li><code>keydown</code>: 当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。</li>
<li><code>keypress</code> 当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发keypress事件。</li>
<li><code>keyup</code>：当用户释放键盘上的键时触发。</li>
<li>触发顺序：<code>keydown</code>、<code>keypress</code>、<code>keyup</code>，<code>keydown</code>、<code>keypress</code> 都是在文本框发生变化之前被触发的; keyup 事件则是在文本框已经发生变化之后被触发的。</li>
<li>如果用户按下了一个字符键不放，就会重复触发 <code>keydown</code> 和<code>keypress</code> 事件，直到用户松开该键为止。</li>
<li><code>keydown</code>、<code>keyup</code> 中的 event 有 keyCode, 与ASCII 码中对应小写字母或数字的编码相同。</li>
</ul>
</blockquote>
<p>##内存和性能</p>
<blockquote>
<ul>
<li>每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。</li>
<li>必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。</li>
</ul>
</blockquote>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;ul id=&quot;myLinks&quot;&gt;</div><div class="line">    &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt;</div><div class="line">    &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt;</div><div class="line">    &lt;li id=&quot;sayHi&quot;&gt;Say hi&lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">(function()&#123;</div><div class="line">   var list = document.getElementById(&quot;myLinks&quot;);</div><div class="line">   EventUtil.addHandler(list, &quot;click&quot;, function(event)&#123;</div><div class="line">   event = EventUtil.getEvent(event);</div><div class="line">   var target = EventUtil.getTarget(event);</div><div class="line">   switch(target.id)&#123;</div><div class="line">     case &quot;doSomething&quot;:</div><div class="line">          document.title = &quot;I changed the document&apos;s title&quot;;</div><div class="line">           break;</div><div class="line">     case &quot;goSomewhere&quot;:</div><div class="line">          location.href = &quot;http://www.wrox.com&quot;;</div><div class="line">           break;</div><div class="line">     case &quot;sayHi&quot;:</div><div class="line">          alert(&quot;hi&quot;);</div><div class="line">           break;</div><div class="line">     &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;)();</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>上面的方法只取得了一个 DOM 元素，只添加了一个事件处理程序，占用的内存更少</li>
<li>最适合采用事件委托技术的事件包块 <code>click</code>、<code>mousedown</code>、<code>mouseup</code>、<code>keydown</code>、<code>keyup</code> 和 <code>keypress</code></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      对基础进行一个总结回顾
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="事件" scheme="http://wayneblog.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>server mock</title>
    <link href="http://wayneblog.cn/2016/12/02/server-mock/"/>
    <id>http://wayneblog.cn/2016/12/02/server-mock/</id>
    <published>2016-12-02T08:35:09.000Z</published>
    <updated>2016-12-02T13:47:32.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、nodejs服务器"><a href="#一、nodejs服务器" class="headerlink" title="一、nodejs服务器"></a>一、nodejs服务器</h2><ol>
<li>为什么要有mock？<br>因为前端在发请求给后端的时候是依赖于后端的响应的，没有得到响应无法进行下一步，所以我们要想方设法自己模拟返回的数据，这个过程就叫做mock；</li>
<li>我们的本地IP是127.0.0.1</li>
<li>server服务器必须监听本地端口，server.listen(‘8888’)</li>
<li><p>要想创建http服务器，须先引用server模块，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>正常的网页返回的是文件而不是字符串，所以我们为了返回文件引入了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;) //nodejs内置的文件系统file system</div></pre></td></tr></table></figure>
</li>
<li><p>用http的createServer创建一个http服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var server = http.createServer(function(request,response)&#123;</div><div class="line">    response.writeHead(200);//返回的状态码</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>fs的readFile方法可以读文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;index.html&apos;,function(error,content)&#123;</div><div class="line">        //因为是回调函数所以必须在readFile后才会触发</div><div class="line">        //正因如此我们必须把返回的结果也放进来，要是放在函数外面的话，可能还没读完文件就赋值了会undefined</div><div class="line">        var fileContent = content.toString();//默认的content是二进制的格式</div><div class="line">        response.end(fileContent);//这是响应的内容</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>nodejs的核心就是理解请求和响应</p>
</li>
<li>默认响应给浏览器的有response.end()还有favicon，我们需要将favicon变成404，即用url来区分</li>
<li>request.method可以知道是用GET请求还是POST请求</li>
<li>整个过程就是，浏览器发送请求给服务器，服务器必须监听了跟浏览器同样的端口才能接收请求并作出响应；服务器会跟句request的需求返回对应的响应，一个请求对应一个响应，不能对应多个响应；</li>
<li>request包括url， response包括状态码+字符串</li>
</ol>
<p><img src="/images/server-mock/server_mock1.jpeg" alt=""><br><img src="/images/server-mock/server_mock2.jpeg" alt=""><br><img src="/images/server-mock/server_mock3.jpeg" alt=""><br><img src="/images/server-mock/server_mock4.jpeg" alt=""><br><img src="/images/server-mock/server_mock5.jpeg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      自己总结的mock数据的方法
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="ajax" scheme="http://wayneblog.cn/tags/ajax/"/>
    
      <category term="server" scheme="http://wayneblog.cn/tags/server/"/>
    
      <category term="mock" scheme="http://wayneblog.cn/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://wayneblog.cn/2016/10/15/RegExp/"/>
    <id>http://wayneblog.cn/2016/10/15/RegExp/</id>
    <published>2016-10-15T06:45:20.000Z</published>
    <updated>2016-12-13T09:33:33.627Z</updated>
    
    <summary type="html">
    
      正则的基础应用
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="标准库、RegExp" scheme="http://wayneblog.cn/tags/%E6%A0%87%E5%87%86%E5%BA%93%E3%80%81RegExp/"/>
    
  </entry>
  
  <entry>
    <title>Ajax&amp;Jsonp</title>
    <link href="http://wayneblog.cn/2016/10/12/ajax&amp;jsonp/"/>
    <id>http://wayneblog.cn/2016/10/12/ajax&amp;jsonp/</id>
    <published>2016-10-12T02:25:20.000Z</published>
    <updated>2016-12-13T05:44:19.912Z</updated>
    
    <summary type="html">
    
      关于ajax在JS和JQ中的总结
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="ajax" scheme="http://wayneblog.cn/tags/ajax/"/>
    
      <category term="jsonp" scheme="http://wayneblog.cn/tags/jsonp/"/>
    
      <category term="cors" scheme="http://wayneblog.cn/tags/cors/"/>
    
      <category term="跨域" scheme="http://wayneblog.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="同域" scheme="http://wayneblog.cn/tags/%E5%90%8C%E5%9F%9F/"/>
    
      <category term="server-mock" scheme="http://wayneblog.cn/tags/server-mock/"/>
    
  </entry>
  
  <entry>
    <title>错误处理机制</title>
    <link href="http://wayneblog.cn/2016/10/08/Error/"/>
    <id>http://wayneblog.cn/2016/10/08/Error/</id>
    <published>2016-10-08T02:25:20.000Z</published>
    <updated>2016-12-13T08:40:39.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Javascript的原生错误类型"><a href="#一、Javascript的原生错误类型" class="headerlink" title="一、Javascript的原生错误类型"></a>一、Javascript的原生错误类型</h2><h3 id="1-SyntaxError"><a href="#1-SyntaxError" class="headerlink" title="1.SyntaxError"></a>1.SyntaxError</h3><p>解析代码时发生的语法错误;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 变量名错误</div><div class="line">var 1a;</div><div class="line"></div><div class="line">// 缺少括号</div><div class="line">console.log &apos;hello&apos;);</div></pre></td></tr></table></figure></p>
<h3 id="2-ReferenceError"><a href="#2-ReferenceError" class="headerlink" title="2.ReferenceError"></a>2.ReferenceError</h3><p>引用一个不存在的变量时发生的错误;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unknownVariable</div><div class="line">// ReferenceError: unknownVariable is not defined</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      JS补充知识
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="http://wayneblog.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript重要知识及知识补充</title>
    <link href="http://wayneblog.cn/2016/10/05/javascript/"/>
    <id>http://wayneblog.cn/2016/10/05/javascript/</id>
    <published>2016-10-05T03:35:09.000Z</published>
    <updated>2016-12-13T15:33:19.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-数据类型、运算符、语句、变量"><a href="#一、-数据类型、运算符、语句、变量" class="headerlink" title="一、 数据类型、运算符、语句、变量"></a>一、 数据类型、运算符、语句、变量</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><ul>
<li>类型：<ul>
<li>基本类型</li>
<li>复杂类型</li>
</ul>
</li>
<li><p>类型检测：</p>
<ul>
<li><strong>typeof xxx</strong> 适用于基本类型和function；返回boolean、number、string、undefined、object、function;typeof null=&gt;object</li>
<li><strong>obj instanceof Function</strong> 适用于对象object，返回布尔值，左边是实例对象，右边是构造函数。它的运算实质是检查右边构建函数的原型对象，是否在左边对象的原型链上。；</li>
<li><p><strong>Object.prototype.toString.call()</strong> 适用于所有，比typeof更精准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//type函数可以替代typeof</div><div class="line">function type(o)&#123;</div><div class="line">	var str = Object.prototype.toString.call(o);</div><div class="line">	var type = str.match(/\[object (.*?)\]/)[1].toLowerCase();</div><div class="line">	return type;</div><div class="line">&#125;</div><div class="line">//判断数据类型返回布尔值</div><div class="line">[&apos;Null&apos;,&apos;Undefined&apos;,&apos;Function&apos;,&apos;Object&apos;,&apos;RegExp&apos;,&apos;Array&apos;,&apos;String&apos;,&apos;Number&apos;,&apos;Boolean&apos;,&apos;NaN&apos;,&apos;Inifinite&apos;].forEach(function(t)&#123;</div><div class="line">	type[&apos;is&apos;+t] = function(o)&#123;</div><div class="line">		return type(o) === t.toLowerCase();</div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>constructor</strong> </p>
</li>
<li><strong>duck type</strong> 根据类型特(属性或者方法)判断</li>
</ul>
</li>
</ul>
<h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><ul>
<li>‘==’ 用相等运算符会先将数据类型做转换再比较<ul>
<li>true ==&gt; 1</li>
<li>false ==&gt; 0</li>
<li>‘11’ ==&gt; 11</li>
<li>object ==&gt; number||string</li>
</ul>
</li>
<li><p>in运算符，主要用于对象，假如运用在数组的话需将数组转换成对象再使用；返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。受原型链影响；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function inArray(arr)&#123;</div><div class="line">	var obj = &#123;&#125;,</div><div class="line">			i;</div><div class="line">	for(i=0;i&lt;arr.length;i++)&#123;</div><div class="line">		obj[arr[i]] = &apos;&apos;;</div><div class="line">	&#125;</div><div class="line">	return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>delete,可以delete在全局和函数中没有用var声明的变量；可以delete对象的属性(完全delete而不是变为undefined)；可以delete数组中的数,变为undefined；</p>
</li>
</ul>
<h3 id="3-语句"><a href="#3-语句" class="headerlink" title="3.语句"></a>3.语句</h3><ul>
<li>for..in..语句<ul>
<li>顺序不确定</li>
<li>受原型链影响</li>
<li>只迭代enumerable:true的</li>
</ul>
</li>
<li>try..catch</li>
<li>for循环中的continue和break<ul>
<li>continue:相当于跳过，一般接在if判断语句后面，判断为true则跳过满足条件的循环而进行后面的循环;</li>
<li>break:直接跳出循环或代码块;</li>
</ul>
</li>
</ul>
<h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h3><ul>
<li>基本类型：在内存中占有一定的实际空间，当赋值后会在内存中创建一个新的副本，保存在栈内存中；</li>
<li>引用类型：在内存中保存的是一个指针，指向堆内存中的对象，赋值的时候也是创建一个新的指针指向对象，多个指针可同时指向一个对象；</li>
</ul>
<h2 id="二、属性标签、对象标签"><a href="#二、属性标签、对象标签" class="headerlink" title="二、属性标签、对象标签"></a>二、属性标签、对象标签</h2><h3 id="1-六种属性标签"><a href="#1-六种属性标签" class="headerlink" title="1.六种属性标签"></a>1.六种属性标签</h3><ul>
<li>value: 存放属性的属性值</li>
<li>writable: 表示value是否可改变，默认true</li>
<li>enumerable: 表示属性是否可枚举，默认true;如果为false，则for..in..和object.keys()会跳过</li>
<li>configurable: 表示可配置性，默认true;如果false,将无法删除该属性，也不能改变属性标签，控制了属性标签的可写性</li>
<li>get: 存放一个函数，表示该属性的取值函数（getter），默认为undefined。</li>
<li>set: set存放一个函数，表示该属性的存值函数（setter），默认为undefined。</li>
</ul>
<h3 id="2-属性标签关联方法"><a href="#2-属性标签关联方法" class="headerlink" title="2.属性标签关联方法"></a>2.属性标签关联方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//用来读取对象属性的标签</div><div class="line">Object.getOwnPropertyDescriptor(obj,&apos;property&apos;)&#123;&#125;</div><div class="line"></div><div class="line">//可定义或修改一个属性，然后返回修改后的对象</div><div class="line">//用Object.defineProperty定义的属性，writable、enumerable、configurable的默认值是false；</div><div class="line">Object.defineProperty(object,&apos;property&apos;,&#123;</div><div class="line">	value:</div><div class="line">	writable:</div><div class="line">	enumerable:</div><div class="line">	configurable:</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//一次性定义或修改多个属性</div><div class="line">Object.defineProperties(obj,&#123;prop1:&#123;&#125;,prop2:&#123;&#125;,prop3:&#123;&#125;...&#125;)</div><div class="line"></div><div class="line">//可获取对象上所有的key除了enumerable:false</div><div class="line">Object.keys(obj);</div><div class="line"></div><div class="line">//获取对象自身的所有属性，不管是否可枚举</div><div class="line">Object.getOwnPropertyNames()</div><div class="line"></div><div class="line">//判断一个属性是否可枚举</div><div class="line">Object.prototype.propertyIsEnumerable()</div></pre></td></tr></table></figure>
<h3 id="3-元属性详解"><a href="#3-元属性详解" class="headerlink" title="3.元属性详解"></a>3.元属性详解</h3><ul>
<li><p><strong>enumerable</strong></p>
<ul>
<li>设置了enumerable:false的属性不被for..in..、Object.keys()、JSON.stringify以上三种方法识别；</li>
<li>考虑到JSON.stringify方法会排除enumerable为false的值，有时可以利用这一点，为对象添加注释信息。</li>
</ul>
</li>
<li><p><strong>configurable</strong></p>
<ul>
<li>当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。</li>
<li>需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。</li>
<li>至于value，只要writable和configurable有一个为true，就允许改动。</li>
<li>configurable为false时，直接对该属性赋值，不报错，但不会成功。</li>
<li>可配置性决定了一个变量是否可以被删除（delete）。为true时才可以被delete</li>
</ul>
</li>
<li><p><strong>writable</strong></p>
<ul>
<li>可写性（writable）决定了属性的值（value）是否可以被改变。</li>
</ul>
</li>
</ul>
<h3 id="4-getter-amp-setter（存取器）"><a href="#4-getter-amp-setter（存取器）" class="headerlink" title="4.getter&amp;setter（存取器）"></a>4.getter&amp;setter（存取器）</h3><ul>
<li>存值函数:setter;使用set命令</li>
<li>取值函数:getter;使用get命令</li>
<li>存取器提供的是虚拟属性，即该属性的值不是实际存在的，而是每次读取时计算生成的。</li>
<li>存取器往往用于，属性的值需要依赖对象内部数据的场合。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//可直接在对象中定义</div><div class="line">var o =&#123;</div><div class="line">  $n : 5,</div><div class="line">  get next() &#123; return this.$n++ &#125;,</div><div class="line">  set next(n) &#123;</div><div class="line">    if (n &gt;= this.$n) this.$n = n;</div><div class="line">    else throw &apos;新的值必须大于当前值&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">o.next // 5</div><div class="line">o.next // 6</div><div class="line"></div><div class="line">o.next = 10;</div><div class="line">o.next // 10</div><div class="line"></div><div class="line">//可在Object.defineProperty中定义</div><div class="line">var d = new Date();</div><div class="line"></div><div class="line">Object.defineProperty(d, &apos;month&apos;, &#123;</div><div class="line">  get: function () &#123;</div><div class="line">    return d.getMonth();</div><div class="line">  &#125;,</div><div class="line">  set: function (v) &#123;</div><div class="line">    d.setMonth(v);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//存取器也可以使用Object.create方法定义</div><div class="line">var o = Object.create(Object.prototype, &#123;</div><div class="line">  foo: &#123;</div><div class="line">    get: function () &#123;</div><div class="line">      return &apos;getter&apos;;</div><div class="line">    &#125;,</div><div class="line">    set: function (value) &#123;</div><div class="line">      console.log(&apos;setter: &apos;+value);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、-函数、闭包、递归、封装"><a href="#三、-函数、闭包、递归、封装" class="headerlink" title="三、 函数、闭包、递归、封装"></a>三、 函数、闭包、递归、封装</h2><h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h3><ul>
<li>函数声明和函数表达式最大的区别就是函数声明会前置;</li>
<li>func.name ==&gt; 函数名  func.length ==&gt; 形参个数</li>
<li>arguments ==&gt; 实参组成的类数组  arguments.callee==&gt;函数本身  arguments.length 实参个数  //在’use strict’中arguments无效 </li>
<li><a href="http://wayneblog.cn/2016/10/02/this/">this</a></li>
</ul>
<h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h3><ul>
<li>变量：当函数被调用后变量就会被释放,闭包中构成的变量是不被释放的;</li>
<li>作用域&amp;作用域链：</li>
<li>闭包概念：如果一个函数可以访问另一个函数作用域的变量，那么前者跟变量共同构成闭包;其实就是子函数可以访问父函数的作用域。</li>
<li>闭包最大的坑： 子函数对父函数变量的引用，是父函数运行结束之后的变量的状态；解决办法就是：子函数对父函数变量的引用，使用运行时的状态；常用的就是自执行函数表达式来解决。</li>
</ul>
<h3 id="3-递归"><a href="#3-递归" class="headerlink" title="3.递归"></a>3.递归</h3><ul>
<li>递归分成两步：<ul>
<li>边界条件，通常是if-else</li>
<li>递归调用</li>
</ul>
</li>
<li>arguments.callee规范已经不推荐使用了，所以不要用这种递归方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//命名函数表达式</div><div class="line">var factorial = (function f(num)&#123;</div><div class="line">	if(num&lt;=1)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;else&#123;</div><div class="line">		return num*f(num-1);</div><div class="line">	&#125;	</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">//arguments.callee，规范已经不推荐使用</div><div class="line">function factorial(num)&#123;</div><div class="line">	if(num&lt;=1)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;else&#123;</div><div class="line">		return num*arguments.callee(num-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-封装"><a href="#4-封装" class="headerlink" title="4.封装"></a>4.封装</h3><ul>
<li>封装块级作用域</li>
</ul>
]]></content>
    
    <summary type="html">
    
      javascript的一些主心骨知识还有自己学习过程中漏掉的知识
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="http://wayneblog.cn/tags/javascript/"/>
    
      <category term="属性标签" scheme="http://wayneblog.cn/tags/%E5%B1%9E%E6%80%A7%E6%A0%87%E7%AD%BE/"/>
    
      <category term="闭包" scheme="http://wayneblog.cn/tags/%E9%97%AD%E5%8C%85/"/>
    
      <category term="递归" scheme="http://wayneblog.cn/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="OOP" scheme="http://wayneblog.cn/tags/OOP/"/>
    
      <category term="标准库" scheme="http://wayneblog.cn/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="http://wayneblog.cn/2016/10/02/this/"/>
    <id>http://wayneblog.cn/2016/10/02/this/</id>
    <published>2016-10-02T04:35:20.000Z</published>
    <updated>2016-12-13T10:04:23.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h2><p>this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">    this.x = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。<br>下面分四种情况，详细讨论this的用法。</p>
<h3 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：<strong>纯粹的函数调用</strong></h3><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。<br>请看下面这段代码，它的运行结果是1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 1;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　test(); // 1</div></pre></td></tr></table></figure></p>
<p>为了证明this就是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　var x = 1;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　test(); // 1</div></pre></td></tr></table></figure></p>
<p>运行结果还是1。再变一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　var x = 1;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 0;</div><div class="line">　　&#125;</div><div class="line">　　test();</div><div class="line">　　alert(x); //0</div><div class="line">window.x === this.x //true</div></pre></td></tr></table></figure></p>
<h3 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：<strong>作为对象方法的调用</strong></h3><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　var o = &#123;&#125;;</div><div class="line">　　o.x = 1;</div><div class="line">　　o.m = test;</div><div class="line">　　o.m(); // 1</div></pre></td></tr></table></figure></p>
<h3 id="情况三-作为构造函数调用"><a href="#情况三-作为构造函数调用" class="headerlink" title="情况三 作为构造函数调用"></a>情况三 <strong>作为构造函数调用</strong></h3><p>所谓构造函数，就是通过这个函数生成一个实例对象（object）。这时，this就指这个实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 1;</div><div class="line">　　&#125;</div><div class="line">　　var o = new test();</div><div class="line">　　alert(o.x); // 1</div></pre></td></tr></table></figure></p>
<p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　var x = 2;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 1;</div><div class="line">　　&#125;</div><div class="line">　　var o = new test();</div><div class="line">　　alert(x); //2</div></pre></td></tr></table></figure></p>
<p>运行结果为2，表明全局变量x的值根本没变。</p>
<h3 id="情况四-apply调用"><a href="#情况四-apply调用" class="headerlink" title="情况四 apply调用"></a><strong>情况四 apply调用</strong></h3><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　var x = 0;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　var o=&#123;&#125;;</div><div class="line">　　o.x = 1;</div><div class="line">　　o.m = test;</div><div class="line">　　o.m.apply(); //0</div></pre></td></tr></table></figure></p>
<p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指向的是全局对象。<br>如果把最后一行代码修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　o.m.apply(o); //1</div></pre></td></tr></table></figure></p>
<p>运行结果就变成了1，证明了这时this指向的是对象o。</p>
<h2 id="二、apply、call、bind方法"><a href="#二、apply、call、bind方法" class="headerlink" title="二、apply、call、bind方法"></a>二、apply、call、bind方法</h2><h3 id="1-apply-amp-call"><a href="#1-apply-amp-call" class="headerlink" title="1.apply()&amp;call()"></a>1.apply()&amp;call()</h3><ul>
<li>作用：<br>call和apply都是为了改变某个函数运行时的上下文(context)而存在的，也就是改变this的指向;Javascript中函数有「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。<br>栗子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   function Foo(animal)&#123;</div><div class="line">       this.animal = animal;</div><div class="line">   &#125;</div><div class="line">   Foo.prototype.say = function()&#123;</div><div class="line">       console.log(this.animal);</div><div class="line">   &#125;;</div><div class="line">   var obj1 = new Foo(&apos;cat&apos;);</div><div class="line">   obj1.say();//cat</div><div class="line"></div><div class="line">   obj2 = &#123;animal:&apos;dog&apos;&#125;;</div><div class="line">   //obj2.say();//报错，因obj2没有定义say方法</div><div class="line">   obj1.say.call(obj2);//dog 调用obj1的say方法并改变this的指向</div><div class="line">obj1.say.apply(obj2);//dog</div></pre></td></tr></table></figure>
</li>
</ul>
<p>所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中obj2没有say方法），但是其他的有（本栗子中obj1有say方法），我们可以借助call或apply用其它对象的方法来操作。</p>
<ul>
<li><p>apply&amp;call的区别<br>其实就是接受的参数不同</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func.call(this,arg1,arg2,...);</div><div class="line">func.apply(this,[arg1,arg2,...]);</div></pre></td></tr></table></figure>
<p>  可以看出call的参数必须<strong>按顺序</strong>传递进去，而apply则是传递一个数组;<br>  JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。<br>  而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数。</p>
</li>
<li><p>apply&amp;call的常见用法</p>
<p>   <strong>数组之间追加</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr1 = [33,44,55,&#123;name:&apos;wayne&apos;&#125;];</div><div class="line">var arr2 = [88,99,22];</div><div class="line">Array.prototype.push.apply(arr1,arr2);</div><div class="line">	</div><div class="line">arr1// [33, 44, 55, Object, 88, 99, 22]</div></pre></td></tr></table></figure>
<p>   <strong>获取数组中的最大值和最小值</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//	number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</div><div class="line">var nums = [21,556,9,-200];</div><div class="line">var maxInNums = Math.max.apply(Math,nums);//556</div><div class="line">var minInNums = Math.min.apply(Math,nums);//-200</div></pre></td></tr></table></figure>
<p>   <strong>验证是否是数组（前提是toString()方法没有被重写过）</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">functionisArray(obj)&#123; </div><div class="line">   	return Object.prototype.toString.call(obj) === &apos;[object Array]&apos; ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   <strong>类（伪）数组使用数组方法</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。</div><div class="line">//但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</div><div class="line"></div><div class="line">var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-bind-方法-ES5的方法-IE9"><a href="#2-bind-方法-ES5的方法-IE9" class="headerlink" title="2.bind()方法(ES5的方法 IE9+)"></a>2.bind()方法(ES5的方法 IE9+)</h3><blockquote>
<p>MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 而我们可以利用bind()直接传入想要的上下文this</div><div class="line"></div><div class="line">var $box = $(&apos;.box&apos;);</div><div class="line">var foo = &#123;</div><div class="line">  animal: &apos;dog&apos;,</div><div class="line">  say_animal: function()&#123;</div><div class="line">    //var _this = this;</div><div class="line">    $box.on(&apos;click&apos;,function()&#123;</div><div class="line">      console.log(this.animal);</div><div class="line">    &#125;.bind(this));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">foo.say_animal();</div><div class="line"></div><div class="line">//还有一个是函数科里化currying的运用</div><div class="line">function getConfig(colors,size,other)&#123;</div><div class="line">	console.log(colors,size,other);</div><div class="line">&#125;</div><div class="line">var defaultConfig = getConfig.bind(null,&apos;yellow&apos;,&apos;1024*768&apos;);</div><div class="line">defaultConfig(&apos;123&apos;);</div><div class="line">defaultConfig(&apos;456&apos;);//前面参数都一样，只有后面的参数需要做改变</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>三种方法的区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    x: 81,</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">var foo = &#123;</div><div class="line">    getX: function() &#123;</div><div class="line">        return this.x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">console.log(foo.getX.bind(obj)());  //81</div><div class="line">console.log(foo.getX.call(obj));    //81</div><div class="line">console.log(foo.getX.apply(obj));   //81</div></pre></td></tr></table></figure>
</li>
</ul>
<p>结论：区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p>
<ul>
<li>apply、call、bind都可以用来改变函数的this对象的指向;</li>
<li>apply、call、bind三者第一个参数都是this要指向的对象，也就是想指定的上下文;</li>
<li>apply、call、bind都可以利用后续参数传参;</li>
<li>bind返回对应函数，便于稍后调用;apply、call则是立即调用;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      总结this和改变this指向的方法
    
    </summary>
    
      <category term="Javascript" scheme="http://wayneblog.cn/categories/Javascript/"/>
    
    
      <category term="this" scheme="http://wayneblog.cn/tags/this/"/>
    
      <category term="apply" scheme="http://wayneblog.cn/tags/apply/"/>
    
      <category term="call" scheme="http://wayneblog.cn/tags/call/"/>
    
      <category term="bind" scheme="http://wayneblog.cn/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://wayneblog.cn/2016/07/02/git/"/>
    <id>http://wayneblog.cn/2016/07/02/git/</id>
    <published>2016-07-02T04:35:40.000Z</published>
    <updated>2016-12-05T04:08:15.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h3><ul>
<li><p>常用git bash命令操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">$ git add </div><div class="line">$ git commit -m &quot;&quot;</div><div class="line">$ git status -sb//简略的描述当前的提交状态,显示分支信息和文件修改信息</div><div class="line">$ git diff xxx//告诉你修改前和修改后，标注修改的地方</div><div class="line">$ git log//查看历史提交</div><div class="line">$ git log --pretty=oneline//简略的查看历史提交</div><div class="line">$ git log --graph --pretty=online --abbrev-commit //可以看到</div><div class="line">$ git reset commitID//版本回退</div><div class="line">$ git reset --hard commitID//这里的commitID通过git reflog查看</div><div class="line">$ git reflog//查看命令历史</div><div class="line">$ git checkout -- xxx//撤销修改；注意中间的两条横杠一定要加，不加就是切换目录</div><div class="line">$ git rm xxx//在版本库删除文件</div><div class="line">$ git remote add origin SSH //可以将本地仓库关联远程仓库，只需要将SSH协议地址复制到那里</div><div class="line">$ git clone SSH //直接从远程版本库克隆到本地</div><div class="line">$ git branch //查看本地分支</div><div class="line">$ git branch -a //查看本地和远程的分支</div><div class="line">$ git pull //将远程版本库更新到本地版本库</div><div class="line">$ git checkout //切换分支</div><div class="line">$ git branch xx //创建分支xx</div><div class="line">$ git checkout -b xx //创建分支xx并切换到该分支</div><div class="line">$ git branch -d xx//本地删除xx分支，不会删除远程的分支</div><div class="line">$ git branch -D xx//强制删除xx分支，不管有没有合并</div><div class="line">$ git push origin :xx //删除远程xx分支</div><div class="line">$ git stash //暂时保存工作现场</div><div class="line">$ git stash list //将当前的git栈信息打印，所有工作现场都会有对应的版本号</div><div class="line">$ git stash apply stash@&#123;num&#125; //恢复到指定版本号</div><div class="line">$ git stash clear //将git栈清空</div><div class="line">$ git stash pop //恢复并清空</div></pre></td></tr></table></figure>
</li>
<li><p>常用命令行操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ pwd ==&gt; process working directory当前所在目录 </div><div class="line">$ ls ==&gt; list </div><div class="line">$ ls -l ==&gt; list -long </div><div class="line">$ ls -a ==&gt; list -all </div><div class="line">$ ls -la === ls -l -a </div><div class="line">$ cat </div><div class="line">$ rm xxx//在工作区删除文件remove</div><div class="line">$ rm -r -f //r代表递归来删除文件夹下所有内容，f代表强制删除</div><div class="line">$ mkdir //make directory</div><div class="line">$ touch //</div><div class="line">$ cp xx1 xx2 //拷贝文件</div><div class="line">$ cp -r xx1 xx2 //拷贝文件夹</div><div class="line">$ mv xx1 xx2 //重命名</div><div class="line">$ head xx //显示前面十行</div><div class="line">$ head -n num xx //显示指定行数</div><div class="line">$ tail xx</div><div class="line">$ tail -n num xx</div><div class="line">$ echo //输入什么打印什么</div><div class="line">$ which xx//给出xx命令的所在地址</div><div class="line">$ sudo //最高权限super user do</div><div class="line">$ whoami //当前使用用户</div><div class="line">$ man ls //查看ls指令的文档</div><div class="line">$ tldr ls //查看ls的缩略文档</div><div class="line">$ $_  //上个输入的文件</div><div class="line">ctrl+A //光标移到最前</div><div class="line">ctrl+E //光标移到最后</div><div class="line">ctrl+K //把当前行删除</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h3><p>1.撤销修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//在工作区直接修改，还没有添加到暂缓区</div><div class="line">$ git checkout -- xxx</div><div class="line">//在工作区修改后并添加到暂缓区</div><div class="line">$ git reset HEAD xxx  //先回退修改</div><div class="line">$ git checkout -- xxx  //再撤销修改 </div><div class="line">//在工作区没有修改直接添加到暂缓区后才修改了文件</div><div class="line">$ git checkout -- xxx</div><div class="line">//若是commit了的话</div><div class="line">$ git log --pretty=oneline  //先查看commit ID,复制需要回退到的id前六位</div><div class="line">$ git reset commitID</div><div class="line">$ git checkout -- xxx</div></pre></td></tr></table></figure></p>
<p>2.删除文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*删除文件*/</div><div class="line">$ rm xxx  //工作区常规删除xxx</div><div class="line">$ git status -sb //会告知工作区中xxx被删除了还没有重新add&amp;commit</div><div class="line">$ git rm xxx  //可以直接将仓库里的xxx也删除了</div><div class="line">$ git commit -m &quot;&quot;</div><div class="line">/*文件删错的操作*/</div><div class="line">$ rm xxx</div><div class="line">$ git checkout -- xxx  //说白了这个操作就是将版本库里的xxx替代工作区中的xxx，因此可以撤销修改也可以还原</div></pre></td></tr></table></figure></p>
<p>3.关于git push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//首次git push</div><div class="line">$ git push --set-upsteam origin master //或者</div><div class="line">$ git push -u origin master //这样设置后，以后都会自动匹配，后面就直接用git push来推送就行了</div></pre></td></tr></table></figure></p>
<p>4.创建新分支feature<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b xx //创建xx分支并切换到该分支</div><div class="line">$ touch xxx;vim xxx;git add xxx;git commit -m &quot;&quot;; //一系列修改并提交</div><div class="line">$ git push origin feature1:feature1 //推送到origin远程仓库，origin是远程版本库的默认名字，后面两个feature1前者是本地分支，后者是远程分支</div><div class="line">$ git checkout master; git merge feature1;// 回到master主分支并合并feature1分支</div><div class="line">$ git branch -d feature1; git push origin :feature1 //删除本地的feature1分支并且删除远处的feature1分支</div></pre></td></tr></table></figure></p>
<p>5.git pull时产生的冲突解决（属于与伙伴之间的远程冲突）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//当改的是同一个地方时，需要协商并作出更改</div><div class="line">$ git pull; git push //当修改完后提交，要是修改的是同一个地方的话这里git pull就会提醒merge conflick</div><div class="line">$ git status -sb //若显示UU，则冲突</div><div class="line">$ vim xxx //</div><div class="line">//本地冲突是&lt;&lt;&lt;和===之间，远程冲突是===和&gt;&gt;&gt;之间</div><div class="line">//git add;git commit</div><div class="line">//git push</div></pre></td></tr></table></figure></p>
<p>6.三种merge的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//第一种方式是Fast-forward，fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit</div><div class="line">$ git merge feature  //这种合并方式的话在log的graph看不到具体的合并</div><div class="line">//第二种是--no-ff，不使用fast-forward方式合并，保留分支的commit历史</div><div class="line">$ git merge --no-ff -m &quot;&quot; feature</div></pre></td></tr></table></figure></p>
<p><img src="/images/git/gitmerge.png" alt=""><br>7.修复Bug<br>工作分支dev工作至一半,保存现场<br><img src="/images/git/1.png" alt=""><br><img src="/images/git/2.png" alt=""><br><img src="/images/git/3.png" alt=""><br><img src="/images/git/4.png" alt=""><br><img src="/images/git/5.png" alt=""><br><img src="/images/git/6.png" alt=""><br><img src="/images/git/7.png" alt=""></p>
<p><a href="http://www.cppblog.com/deercoder/archive/2011/11/13/160007.aspx" target="_blank" rel="external">关于为什么要用git stash</a></p>
]]></content>
    
    <summary type="html">
    
      自己总结的常用的git命令实际应用
    
    </summary>
    
      <category term="个人总结" scheme="http://wayneblog.cn/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="git" scheme="http://wayneblog.cn/tags/git/"/>
    
  </entry>
  
</feed>
